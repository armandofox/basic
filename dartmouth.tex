
\section{DARTMOUTH COLLEGE, 1964 - FOCUS ON SIMPLICITY}

\makequotation{In cases where there is a choice between simplicity and efficiency,
simplicity is chosen.}{Time Sharing Project Memorandum \#1,
Dartmouth College, November 6, 1963~\cite{hopl}} 

Kemeny initially tried to convince Kurtz to teach students FORTRAN, a
very successful high-level language invented by IBM in 1957 for
scientists and engineers to express mathematical problems.
But Kurtz felt strongly that FORTRAN's many idiosyncrasies, which made
the language easy to compile without being too unfriendly to scientists
and engineers, would drive
nontechnical learners away.

\begin{tangent} For example, FORTRAN lacks type declarations for numeric
  variables: instead,
  variable names beginning with letters I through N always represent
  integers, whereas variable names starting with other letters always
  represent floating-point numbers.
This naming rule is consistent with mathematical notation, in which
$i$ through $n$ are typically used as integer subscripts, but seems
arbitrary to someone unfamiliar with that notation.
Similarly, FORTRAN's conditional statement originally had the form
\T{IF}~\emph{condition,label1,label2,label3}, which is easy 
to parse but requires the reader to remember that \emph{condition} was
really just an arithmetic expression and the three labels 
corresponded to the jump targets depending whether
\emph{condition} was negative, zero, or positive.  
In contrast, BASIC doesn't distinguish between
integers and floating-point numbers, has a Boolean-valued conditional
statement, and doesn't require declaring variables in advance.
\end{tangent}

Kemeny was persuaded by Kurtz's argument that a new language 
designed specifically for nontechnical beginners was needed.
Its design would be focused on ease of learning
and ease of use, since only \emph{reasonable} performance was necessary
for the simple programs beginners would write.
Kurtz called the language BASIC, for Beginners' All-purpose Symbolic
Instruction Code.
BASIC also  borrowed good ideas from other languages.
Like COBOL\footnote{COmmon Business-Oriented Language, designed for creating
business applications such as payroll and inventory.}, every line of a BASIC
program would start with one of 15 English-like \emph{keywords}, as Figure~\ref{fig:keywords} shows,
making its syntax consistent and easy
to learn.

\tablefigure{figs/keywords.tex}{fig:keywords}{Although some dialects later departed from the
convention that all statements must begin with one of these 15 keywords, the characteristic
was retained and exploited by Woz's Apple Integer BASIC and by Sinclair
ZX80 BASIC~\cite{zx80_basic_techreport}
to check the syntax of each line as it was typed in, rather than when
the program was run.}

BASIC also tried to shield beginning users from having to deal with the
operating system, which was as confusing in 1964 as Unix is to
nontechnical learners today.
Much as today's cloud-based IDEs replace command-line filesystem
navigation with a ``file explorer'' GUI---you don't even know where in
the cloud your files are stored---Kurtz added the commands
\T{SAVE}~\emph{name} (store a copy of your current program),
\T{OLD}~\emph{name} to retrieve it, \T{NEW} to erase the current program
and start a new one, and \T{RUN} to compile and run the current program.
These commands weren't technically part of BASIC, but many students
thought they were because they could be executed from within the BASIC
environment.  This trend persisted with PCs, many of which booted
directly into a BASIC read-eval-print loop at power-up, giving the
newbie learner the impression that BASIC \emph{was} the operating system.

\codefilefigure{figs/jcl_example.txt}{fig:jcl_example}{%
Before BASIC, simple system tasks had to be scripted in  a separate
\w{job control} language, analogous to a shell script or 
Makefile today.  This code in JCL (the Job Control Language used on IBM
mainframes prevalent at BASIC's birth) copies \T{OLDFILE} to \T{NEWFILE}.}

These ``faux OS'' commands persisted in PC BASICs (with \T{OLD} renamed
\T{LOAD} in 
most of them) because early PCs didn't have operating systems at all, so
the commands provided a crude abstraction to the underlying disk or tape
hardware.
In this sense, the original BASIC and its descendants were primitive
forerunners of today's beginner-friendly IDEs.

All of these concessions to beginners complicated the compiler and
runtime system, which were
implemented by a team of undergraduates,
but they did make the language easy to learn.
The original 1964 BASIC manual~\cite[p. 14]{dartmouth_basic_manual}
consists of a 10-page (double-spaced) exposition of the language
itself, and the following HOWTO for students:
Walk up to an ASR-33 terminal, type \T{HELLO}, enter your student ID
number when asked, and type the name of the system you want to use
(\T{BASIC}).
That's the entire contents of the section on ``how to use the computer
system'': three pages, one of which is a full-page diagram of the ASR-33
keyboard explaining keys such as \T{CTRL} and \T{ESC} to 1964
typists.

\begin{tangent}
  BASIC programs were compiled and had
  far better performance than the interpreted BASICs that would
  accompany PCs. But interpreters are easier and more compact to write, which
  was an important advantage in securing BASIC's dominance on
  early PCs with extremely limited hardware.
\end{tangent}

% (film: montage of power-on sequences of various home computers)

The use of timesharing rather than batch processing influenced
BASIC's syntax as well.
With programs entered on a line-at-a-time printing terminal (affordable CRT
terminals were years away) rather than supplied on decks of punched
cards, how could learners easily specify the order of program execution
as they typed in program lines?
The ingenious solution was that each line in a BASIC
program would begin with a number, and the program would be
executed in order of ascending line numbers, which didn't have to be
consecutive.  
It didn't matter in what order the lines were entered;
typing \T{LIST} would show
you all or part of your program in line-number order,
and beginners were encouraged to leave gaps in line
numbering (10, 20, 30, etc.) so they could add
more lines later.  (To delete a line, you just entered a line
consisting of the line number only.)

  \begin{tangent}
  The convention of line numbers was retained in virtually all ``street
  BASICs'' long after cursor-addressable CRT terminals were ubiquitous,
  and was finally dropped in Microsoft Visual Basic (although many modern
  BASICs, including VB, still allow them).
  \end{tangent}

BASIC was also the first high-level language to include a keyword
(\T{INPUT}) that means ``stop and wait for
the user to type something,'' a concept that makes no sense in batch
processing. 

  \begin{tangent}
  BASIC's \T{READ} and \T{DATA} statements are based on their
  counterparts in FORTRAN.  BASIC's \T{READ} consumes values from a
  separate \T{DATA} statement, whereas FORTRAN's \T{READ} consumes
  values from data cards.
  \end{tangent}

Dartmouth's  collaboration with General Electric on creating BASIC and a
timesharing OS for their computer would be pivotal in another way.
GE engineer Chuck Peddle was among the first non-Dartmouth engineers to
be exposed to
BASIC, literally the day after the language was
invented~\cite[p.~5]{commodore}.
Fifteen years later, Peddle would design the 6502 microprocessor, which launched
a revolution powered by hobbyist PCs, and his choice of BASIC as the
language of choice for those computers would turn it into the most
widely-used computer language in the world.


