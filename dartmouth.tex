
\section{DARTMOUTH COLLEGE, 1964 - FOCUS ON SIMPLICITY}

\makequotation{In cases where there is a choice between simplicity and efficiency,
simplicity is chosen\ldots{}no attempt will be made at making the use of the Time Sharing 
equipment be compatible with \emph{standard use of a computer.}}{Time Sharing Project Memorandum \#1,
Dartmouth College, November 6, 1963~\cite{hopl}} 

\picfigure{figs/ASR33.jpg}{fig:ASR33}{The Teletype ASR-33 printing
  terminal.}

It was a bold decision that the new timesharing
``environment'' in which beginners would learn programming need not have
anything in common with the batch-processing environment used by
scientists and engineers (the ``standard use of a computer'' in the
quote above). 

Kemeny tried to convince Kurtz to teach students to program using FORTRAN, 
a language devised by IBM in 1957 for scientists and
engineers to express mathematical problems.  
FORTRAN was phenomenally successful among engineers and scientists,
But Kurtz felt strongly that since FORTRAN had
been designed for professionals,
its idiosyncrasies might discourage beginners.  Further, the design of
FORTRAN made some 
compromises that improved its performance (very important for its target
audience of experts) but made the language harder
for a nonexpert to learn and use.

\begin{geeknote}{}
For example, FORTRAN variable names beginning with letters I
through N always represented integers, whereas other variables represented
real numbers, allowing the compiler to use much faster
integer-arithmetic routines when needed; in BASIC, a number is a number.  
FORTRAN required you to
declare in advance all the variables you would use, so the compiler
could preallocate enough space all at once rather than having to pause
and allocate space each time a new variable was set up; BASIC didn't
requir any declarations at all.
FORTRAN's
conditional statement originally had the form 
\T{IF}~\emph{condition,label1,label2,label3}, which was easy for the
compiler to parse but required the reader to
understand the meaning of the punctuation; BASIC uses the more
English-like \T{IF}~\emph{condition}~\T{THEN}~\emph{label}
clarify intent.  FORTRAN's \T{DO} loop body always executes at least once,
even if the condition at the top of the loop is initially false; not
so for BASIC's \T{FOR\ldots{}NEXT} loop.
Other examples abound.
\end{geeknote}


Kurtz decided to design a new language specifically for beginners.
Everything about it would be focused on ease of learning and ease of
use, since only \emph{reasonable} performance was necessary for the
simple programs beginners would write.
He called the language BASIC, for Beginners' All-purpose Symbolic
Instruction Code.
BASIC borrowed good ideas from other languages.
Like COBOL (COmmon Business-Oriented Language, designed for creating
business applications as payroll and inventory), every line of a BASIC
program would start with an English-like command word, such as
\T{PRINT}, \T{IF}, or \T{GO~TO}.
The original BASIC had only 14 commands, and used arithmetic notation
that would be familiar to anyone with high school algebra knowledge.
BASIC's simple
design made it possible for a team of undergraduates to design the
\w{compiler}, a complex program that translates students' BASIC programs
into the ``native'' programs the computer can run.

  \begin{geeknote}
   Although some street BASICs (and Microsoft BASIC) departed from the
   convention that all statements begin with a verb, 
   the characteristic was exploited by Woz's Apple Integer BASIC and by
   Sinclair ZX80 BASIC to 
    provide a context-sensitive syntax checker that verified the syntax
    of your BASIC program lines as you typed them, rather than at
    runtime~\cite{zx80_basic_techreport}.  Woz's BASIC also stored the
    program in a parsed form that distinguished different uses of the
    same BASIC keyword, saving time during execution.
  \end{geeknote}

The original 1964 BASIC manual~\cite[p. 14]{dartmouth_basic_manual}
makes clear that the creators' intent was not just a beginner-friendly
language, but a whole beginner-friendly system.
After a short (10-page double-spaced) exposition of BASIC itself, the
manual explains the steps students must take to begin writing programs:
walk up to a Model 33 terminal, type \T{HELLO}, enter your student ID
number when asked, and then type the name of the system you want to use
(\T{BASIC}).
That's the entire contents of the section on ``how to use the computer
system'': three pages, one of which is a full-page diagram of the ASR-33
keyboard explaining weird keys such as \T{CTRL} and \T{ESC} to 1964
typists.
In contrast, batch-processing systems required programmers to learn and
use a separate and different \w{job control} language to instruct the
computer how to run their program.
Job control languages were powerful but clumsy and difficult to learn
(see Figure~\ref{fig:jcl_example} for an example), and Kurtz reasoned
that most beginners wouldn't need most of their features anyway, so he
``built into'' the BASIC language a few simple features that beginners
would need to use: \T{SAVE} stored a copy of the current program with a
name chosen by the programmer, \T{OLD} (later \T{LOAD} in Street BASIC)
retrieved a previously-stored program, and \T{NEW} erased the current
program in order to start new work.
All of these commands were part of the language, shielding novices
from having to mutter inscrutable incantations to do these simple
tasks.
This bold move would remain a characteristic of PC BASICs, in part
necessitated by the low cost and modest resources of those machines.

\codefilefigure{figs/jcl_example.txt}{jcl_example}{The incantations
  necessary to make a copy of an existing file \T{OLDFILE} and give it
  the name \T{NEWFILE} in JCL, the Job Control Language used on most IBM
  mainframes.}


% (film: montage of power-on sequences of various home computers)


BASIC was also influenced by the technology of the time.  
Since FORTRAN was used in batch mode, and each line of a FORTRAN program
required one punched card, the order of program statements was
determined by the order of the punched cards in the program deck.  It
didn't matter in what order the programmer typed the lines, as long as
the cards were arranged in the right order when fed to the computer.
%% With CRT terminals years away, how to specify the order of statements in
%% a BASIC program?  Indeed, how to shield beginners from having to learn
%% to work with other elements of the computer system, such as files and editors?
But 
Kemeny and Kurtz had done away with punched cards in favor of
timesharing, so they
came up with an ingenious solution to the problem of
how to specify the order of BASIC statements.  Each line in a BASIC
program would begin with a number, and the program would be
executed in order of ascending line numbers, which didn't have to be
consecutive.  
Typing a line of text consisting of a number followed by a BASIC statement
would create (or replace) that line in the current program.
Typing a line of text consisting of only a line number would delete that line.
Typing \T{LIST} would show
you all or part of your program in line-number order.
Beginners were encouraged to leave gaps in line
numbering---for example, 10, 20, 30, and so on---so 
extra lines could be added later by choosing numbers in between
existing line numbers.

  \begin{geeknote}
  The convention of line numbers was retained in virtually all ``street
  BASICs'' long after cursor-addressable CRT terminals were ubiquitous,
  and was finally dropped in Microsoft Visual Basic (although many modern
  BASICs, including VB, still allow them).
  \end{geeknote}

Another technological innovation in which BASIC helped democratize
computing was the addition of the \T{INPUT}
statement, which means ``At this point in the program, stop and wait for
the user to type something, then record what was typed and proceed.''
With batch processing, the
idea of the computer stopping and waiting for a human to type was
ludicrous, so all data on which a program operated would have to be
supplied as part of the deck of punch cards.
But with timesharing, the time ``wasted'' in waiting for the user to
type something could be used to work on other users' jobs, so
the idea of programs that would interact with the
user became a reality.  BASIC was the first high-level language to
support this concept directly.

  \begin{geeknote}
  BASIC's \T{READ} and \T{DATA} statements are based on their
  counterparts in FORTRAN.  BASIC's \T{READ} consumes values from a
  separate \T{DATA} statement, whereas FORTRAN's \T{READ} consumes
  values from data cards.
  \end{geeknote}

These examples show how Kurtz and Kemeny worked around the technology of their
time without cluttering the concepts that beginners would learn.
Today, universities with world-class computer science
departments like to boast that their introductory programming courses
reach over 90\% of
students across all departments (need cite), but
Dartmouth achieved this by 1971~\cite{man_and_computer} by instituting the farsighted 
vision of BASIC's creators.



