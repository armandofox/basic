
\section{DARTMOUTH COLLEGE, 1964 - FOCUS ON SIMPLICITY}

\makequotation{In cases where there is a choice between simplicity and efficiency,
simplicity is chosen\ldots{}no attempt will be made at making the use of the Time Sharing 
equipment be compatible with \emph{standard use of a computer.}}{Time Sharing Project Memorandum \#1,
Dartmouth College, November 6, 1963~\cite{hopl}} 

It was a bold decision that the new timesharing
``environment'' in which nontechnical beginners would learn programming need not have
anything in common with the batch-processing environment used by
scientists and engineers (the ``standard use of a computer'' in the
quote above). 

Kemeny initially tried to convince Kurtz to teach students FORTRAN, a
very successful high-level language invented by IBM in 1957 for
scientists and engineers to express mathematical problems.
But Kurtz felt strongly that FORTRAN's many idiosyncrasies, resulting
from a desire to make it easy to compile source programs into
high performance code, made the language needlessly difficult for a
nontechnical person to learn.

\begin{tangent} For example, FORTRAN lacks type declarations for numeric
  variables: instead,
  variable names beginning with letters I through N always represent
  integers, whereas variable names starting with other letters always
  represent floating-point numbers.
This naming rule is consistent with mathematical notation, in which
$i$ through $n$ are typically used as integer subscripts, for example,
to count loop iterations or index into arrays.
But for someone without math background, the naming rule seems arbitrary.
Similarly, FORTRAN's conditional statement originally had the form
\T{IF}~\emph{condition,label1,label2,label3}, which is easy 
to parse but requires the reader to remember that \emph{condition} was
really just an arithmetic expression and the three labels 
corresponded to the jump targets depending whether
\emph{condition} was negative, zero, or positive.  For a computer
person, this makes sense, since comparisons such as $A<B$ are performed 
by subtracting $A-B$ and examining if the result is negative, positive
or zero.
But a lay person thinks of a comparison as resulting in logical true or
false: is A less than B or not?
\end{tangent}

Kemeny was persuaded by Kurtz's argument that a new language was needed,
designed specifically for beginners without math or science backgrounds.
Everything about the new language would be focused on ease of learning
and ease of use, since only \emph{reasonable} performance was necessary
for the simple programs beginners would write.
Kurtz called the language BASIC, for Beginners' All-purpose Symbolic
Instruction Code.

BASIC borrowed good ideas from other languages.
Like COBOL (COmmon Business-Oriented Language, designed for creating
business applications as payroll and inventory), every line of a BASIC
program would start with one of 15 English-like \emph{keywords}, as Figure~\ref{fig:keywords} shows,
making its syntax consistent and easy
to learn.

\tablefigure{figs/keywords.tex}{fig:keywords}{Although some dialects later departed from the
convention that all statements must begin with one of these 15 keywords, the characteristic
was retained and exploited by Woz's Apple Integer BASIC and by Sinclair
ZX80 BASIC~\cite{zx80_basic_techreport}
to check the syntax of each line as it was typed in, rather than when
the program was run.}

BASIC also tried to eliminate needlessly confusing (for beginners)
distinctions in other languages: there is no distinction between
integers and floating-point numbers, the conditional statement is
friendlier, and scalar variables don't need to be declared in advance.
All of these concessions to beginners complicate the compiler, which was
implemented by a team of undergraduates.

\begin{tangent}
  Since BASIC's heyday was on PCs where it was provided as an
  interpreter, some people are surprised to hear that it was originally
  implemented as a compiled language.  Compiled BASIC programs had quite
  good performance---far better than the interpreted BASICs that would
  follow---but interpreters are easier and more compact to write, which
  was an important advantage in securing BASIC's dominance on
  early PC's with extremely limited hardware.
\end{tangent}

BASIC also tried to shield beginning users from having to deal with
the operating system, much as today's cloud-based IDEs try
to abstract away the concept of (for example) knowing where your files
are stored and what commands are needed to build and run a program.
To understand how big a step this was, consider that batch-processing
systems of that time required programmers to learn and use a separate
\w{job control} language to script basic tasks such as 
running a program or copying a file (analogous to a shell script or
Makefile today), as 
Figure~\ref{fig:jcl_example} shows.
Kurtz reasoned that most beginners would only need
to save their work and restore programs they
had already written, so he added a few commands to the operating system
such as 
\T{SAVE}, to
store a copy of the current program under a name chosen by the
programmer, \T{OLD}  to retrieved a
previously-stored program by name, \T{NEW} to erase the current program 
and start a new one, and \T{RUN} to compile and execute the current
program.
These commands weren't technically part of BASIC, but many students
thought they were because they could be executed from within the BASIC
environment.  This trend
remained a characteristic of PC BASICs, in part necessitated by the low
cost and modest resources of early PCs.  \T{OLD} became \T{LOAD} in
most PC BASICs, but \T{NEW} and \T{SAVE} survive in virtually all
dialects as commands available from BASIC that provide an interface to specific
narrow functionality in the underlying OS.  In this sense, the original BASIC
and its descendants were primitive forerunners of today's
beginner-friendly IDEs.

\codefilefigure{figs/jcl_example.txt}{fig:jcl_example}{%
Job control languages in 1964 were powerful, but clumsy and difficult to
learn.  This code in JCL (the Job Control Language used on IBM
mainframes prevalent at BASIC's birth) copies \T{OLDFILE} to \T{NEWFILE}.}

The original 1964 BASIC manual~\cite[p. 14]{dartmouth_basic_manual}
illustrates the success of the creators in making BASIC simple to get
started with.
After a short (10-page double-spaced) exposition of the language itself, the
manual explains the steps students must take to begin writing programs
on a Teletype ASR-33 terminal: Type \T{HELLO}, enter your student ID
number when asked, and then type the name of the system you want to use
(\T{BASIC}).
That's the entire contents of the section on ``how to use the computer
system'': three pages, one of which is a full-page diagram of the ASR-33
keyboard explaining keys such as \T{CTRL} and \T{ESC} to 1964
typists.


% (film: montage of power-on sequences of various home computers)


BASIC's syntax was also influenced by the technology of the time.  
Since other high-level languages like FORTRAN had always been used in
batch mode, and each line of a FORTRAN program 
required one punched card, the order of program statements was
determined by the order of the punched cards in the program deck.
It
didn't matter in what order the programmer typed the lines, as long as
the punched cards were arranged in the right order when fed to the computer.
\begin{sidebar}{}
FORTRAN statements can have associated line numbers, but the line
numbers serve only as labels for jump targets and do not affect the
order in which the lines are executed.
\end{sidebar}
%% With CRT terminals years away, how to specify the order of statements in
%% a BASIC program?  Indeed, how to shield beginners from having to learn
%% to work with other elements of the computer system, such as files and editors?
But 
Kemeny and Kurtz had done away with punched cards in favor of
interactive timesharing, so they
came up with an ingenious solution to the problem of
how to specify the order of BASIC statements.  (Remember that CRT
terminals and therefore screen-based editors were years away.)
Each line in a BASIC
program would begin with a number, and the program would be
executed in order of ascending line numbers, which didn't have to be
consecutive.  
Typing a line of text consisting of a number followed by a BASIC statement
would create (or replace) that line in the current program.
Typing a line of text consisting of only a line number would delete that line.
Typing \T{LIST} would show
you all or part of your program in line-number order.
Beginners were encouraged to leave gaps in line
numbering---for example, 10, 20, 30, and so on---so 
extra lines could be added later by choosing numbers in between
existing line numbers.

  \begin{tangent}
  The convention of line numbers was retained in virtually all ``street
  BASICs'' long after cursor-addressable CRT terminals were ubiquitous,
  and was finally dropped in Microsoft Visual Basic (although many modern
  BASICs, including VB, still allow them).
  \end{tangent}

Another technological innovation in which BASIC helped democratize
computing was the addition of the \T{INPUT}
statement, which means ``At this point in the program, stop and wait for
the user to type something, then record what was typed and proceed.''
With batch processing, the
idea of the computer stopping and waiting for a human to type was
ludicrous, so all data on which a program operated would have to be
supplied as part of the deck of punch cards.
But with timesharing, the time ``wasted'' in waiting for the user to
type something could be used to work on other users' jobs, so
the idea of programs that would interact with the
user in real time became a reality.  BASIC was the first high-level language to
support this concept directly.

  \begin{tangent}
  BASIC's \T{READ} and \T{DATA} statements are based on their
  counterparts in FORTRAN.  BASIC's \T{READ} consumes values from a
  separate \T{DATA} statement, whereas FORTRAN's \T{READ} consumes
  values from data cards.
  \end{tangent}

These examples show how Kurtz and Kemeny worked around the technology of their
time without cluttering the concepts that beginners would learn.
Today, universities with world-class computer science
departments like to boast that their introductory programming courses
reach over 90\% of
students across all departments (need cite), but
Dartmouth achieved this by 1971~\cite{man_and_computer} by instituting the farsighted 
vision of BASIC's creators.

Fatefully, the Dartmouth/GE timesharing collaboration also
gave GE engineer Chuck Peddle his first exposure to
BASIC, literally the day after the language was
invented~\cite[p.~5]{commodore}.
Fifteen years later, Peddle would design the 6502 microprocessor, which launched
the PC revolution, and he would select BASIC as the language of choice for
6502-powered hobbyist computers, turning BASIC into the most
widely-used computer language in the world.


