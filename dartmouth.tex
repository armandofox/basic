
\section{DARTMOUTH, 1964 - KEEP IT SIMPLE}

\makequotation{In cases where there is a choice between simplicity and efficiency,
simplicity is chosen.}{Time Sharing Project Memorandum \#1,
Dartmouth College, November 6, 1963~\cite{hopl}} 

Kemeny initially tried to convince Kurtz to teach students FORTRAN, a
very successful high-level language invented by IBM in 1957 for
scientists and engineers to express mathematical problems.
But Kurtz felt strongly that FORTRAN's notational idiosyncrasies, which made
the language easy for a computer to digest while still looking familiar to scientists
and engineers, would drive
nontechnical learners away.

\begin{tangent} 
%% In contrast, BASIC  doesn't require declaring variables in advance, 
%% doesn't distinguish between
%% integers and floating-point numbers (there's a single numeric type,
%% which is roughly double-precision floating-point), and
%% has a Boolean-valued conditional
%% statement with the easy-to-remember syntax \T{IF}~\emph{cond}
%% \T{THEN}~\emph{label}.
Compiler construction is so well understood today that most CS
undergraduates build one as part of a course.
But when FORTRAN was born, the simplest programming-language
parser (the 
\w[History of compiler construction]{LR parser}) was ten years in the
future (it would be invented by computer science legend Donald Knuth),
and parser generators like \T{yacc} certainly didn't exist.  The
compilers for FORTRAN (1957) and BASIC (1964) therefore had to wing it,
so it's understandable that FORTRAN's language syntax
reflects some concessions to ease of parsing.
For example, in FORTRAN
variable names beginning with letters I through N always represent
integers, whereas variable names starting with other letters always
represent floating-point numbers.
This naming rule is consistent with mathematical notation, in which
$i$ through $n$ are typically used as integer subscripts, but seems
arbitrary to someone unfamiliar with that notation.
Similarly, FORTRAN's conditional statement originally had the form
\T{IF}~\emph{expr,label1,label2,label3}, which is easy
for a primitive parser to digest
but requires the programmer to remember that the three labels 
correspond to the jump targets depending on whether the result of
\emph{expr} (which must be a mathematical, not Boolean, expression) is negative, zero, or positive.  

\end{tangent}

Kemeny was persuaded by Kurtz's argument that a new language 
designed specifically for nontechnical beginners was needed.
Its design would be focused on ease of learning
and ease of use, since only \emph{reasonable} performance was necessary
for the simple programs beginners would write.
Kurtz called the language BASIC, for Beginners' All-purpose Symbolic
Instruction Code.
BASIC also  borrowed good ideas from other languages.
Like COBOL\footnote{COmmon Business-Oriented Language, designed for creating
business applications such as payroll and inventory.}, every statement in a BASIC
program would start with one of 15 English-like \emph{keywords}, as Figure~\ref{fig:keywords} shows,
making its syntax consistent and easy
to learn.

\tablefigure{figs/keywords.tex}{fig:keywords}{BASIC in one table.  Although some dialects later departed from the
convention that all statements must begin with one of these 15 keywords, the characteristic
was retained and exploited by Woz's Apple Integer BASIC and by Sinclair
ZX80 BASIC~\cite{zx80_basic_techreport}
to check the syntax of each line as it was typed in, rather than when
the program was run.  All
  variables are global; numeric variables (scalar or array) begin with a letter and there
  is only a floating-point numeric type (like JavaScript); string
  variable names are suffixed with \$.  BASIC's \T{READ} and \T{DATA} statements are based on their
  counterparts in FORTRAN, but whereas FORTRAN's \T{READ} consumes
  values from data cards, BASIC's \T{READ} consumes values from a
  separate \T{DATA} statement.
}

BASIC also tried to shield beginning users from having to deal with
the operating system, which was as confusing in 1964 as Unix is to
nontechnical learners today.
Much as today's graphical user interface replaced the command line for
most users (you just drag files to folders, without worrying about how
the file storage actually happens), Kurtz added the commands
\T{SAVE}~\emph{name} to store a copy of your current program,
\T{OLD}~\emph{name} to retrieve it, \T{NEW} to erase the current
program and start a new one, and \T{RUN} to compile and run the
current program.
These commands weren't technically part of BASIC, but many students
thought they were, because they could be executed from within the
BASIC environment.
These ``faux OS'' commands persisted in PC BASICs (with \T{OLD}
renamed \T{LOAD} in most of them, and adapted to store programs on
audio cassettes rather than disk drives) because early PCs either didn't have
operating systems at all or had a fuzzy separation at best between the
BASIC interpreter in ROM and the ROM~BIOS (Basic Input/Output System,
a sort of primitive OS kernel).
Indeed, until the advent of MS-DOS, most personal computers booted
from ROM directly into the BASIC interpreter's \w{read-eval-print loop}, giving
the newbie learner the impression that BASIC \emph{was} the operating
system.
In this sense, the original BASIC and its descendants were primitive
forerunners of today's beginner-friendly IDEs.

\codefilefigure{figs/jcl_example.txt}{fig:jcl_example}{%
Before BASIC, simple system tasks had to be scripted in  a separate
\w{job control} language, analogous to a shell script or 
Makefile today.  This code in JCL (the Job Control Language used on IBM
mainframes prevalent at BASIC's birth) creates a copy of \T{OLDFILE}
with the name \T{NEWFILE}.}

All of these concessions to beginners complicated the compiler and
runtime system, which were
implemented by a heroic team of undergraduates,
but they did make the language easy to learn.
The original 1964 BASIC manual~\cite[p. 14]{dartmouth_basic_manual}
consists of a 10-page (double-spaced) exposition of the language
itself, and the following HOWTO for students:
Walk up to an ASR-33 terminal, type \T{HELLO}, enter your student ID
number when asked, and type the name of the system you want to use
(\T{BASIC}).
That's the entire contents of the section on ``how to use the computer
system'': three pages, one of which is a full-page diagram of the ASR-33
keyboard explaining keys such as \T{CTRL} and \T{ESC} to 1964
typists.

\begin{tangent}
  Dartmouth BASIC programs were compiled and had
  far better performance than the interpreted BASICs that would
  accompany PCs. But interpreters are easier and more compact to write, which
  was an important advantage in securing BASIC's dominance on
  early PCs with extremely limited hardware.  
\end{tangent}

% (film: montage of power-on sequences of various home computers)

The use of timesharing rather than batch processing influenced
BASIC's syntax as well.
With programs entered on a line-at-a-time printing terminal
(affordable video display
terminals were years away) rather than supplied on decks of punched
cards, how could learners easily specify the order of program execution
as they typed in program lines?
The ingenious solution was that each line in a BASIC
program would begin with a number, and the program would be
executed in order of ascending line numbers, which didn't have to be
consecutive.  
It didn't matter in what order the lines were entered;
typing \T{LIST} would show
you all or part of your program in line-number order,
and beginners were encouraged to leave gaps in line
numbering (10, 20, 30, etc.) so they could add
more lines later.  (To delete a line, you just entered a line
consisting of the line number only.)

  \begin{tangent}
  The convention of line numbers was retained in virtually all ``street
  BASICs'' long after cursor-addressable CRT terminals were ubiquitous,
  and was finally dropped in Microsoft Visual Basic (although many modern
  BASICs, including VB, still allow them).
  \end{tangent}

BASIC was also the first high-level language to include a keyword
(\T{INPUT}) that means ``stop and wait for
the user to type something,'' a concept that makes no sense in batch
processing. 
Dartmouth's collaboration with General Electric on creating BASIC and
a timesharing OS for their computer would be pivotal in two other
ways.
General Electric engineer Chuck Peddle was among the first
non-Dartmouth engineers to be exposed to BASIC, literally the day
after the language was invented~\cite[p.~5]{commodore}.
Fifteen years later, Peddle would design the 6502 microprocessor,
which launched a revolution powered by hobbyist PCs, and his choice of
BASIC as the language to ``build into'' those computers would turn it
into the most widely-used computer language in the world.
GE opened a handful of regional computing centers featuring timeshared
computers offering Dartmouth BASIC.
One of these centers, in Seattle, attracted a talented high school
student named Bill Gates, who got his first exposure to using
BASIC~\cite{basic_history_gdm} and would later launch one of the
world's most successful software companies.
That company's first product would be a version of BASIC that worked
on then-brand-new personal computers.
But while Gates finished high school and entered Harvard University as
an undergraduate, a cultural revolution was brewing that would set
Gates's future company on a collision course with the hippies of
northern California.





